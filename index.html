<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kretzonizer v3.8</title>
    <style>
        /* --- Styles --- */
        body { background: #1a1a1a; color: white; font-family: Arial, sans-serif; padding: 20px; margin: 0; }
        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
        header, footer { text-align: center; margin-bottom: 20px; }
        h1 { margin: 10px 0; }
        .controls { background: #2a2a2a; padding: 20px; border-radius: 8px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; }
        .control-group { padding: 12px; border: 1px solid #383838; border-radius: 6px; background-color: #2f2f2f; display: flex; flex-direction: column; }
        .control-group h3 { margin-top: 0; margin-bottom: 12px; color: #4CAF50; border-bottom: 1px solid #444; padding-bottom: 8px; text-align: center; }
        .control-group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .control-group-header h3 { margin-bottom: 0; border-bottom: none; padding-bottom: 0; text-align: left; }
        .control-row { margin-bottom: 10px; display: flex; align-items: center; flex-wrap: wrap; width: 100%; }
        label { width: 75px; display: inline-block; margin-right: 5px; font-size: 0.82em; color: #ccc; flex-shrink: 0; }
        input[type="range"] { flex-grow: 1; margin: 0 5px; min-width: 80px; cursor: pointer; }
        input[type="range"]:disabled { opacity: 0.4; cursor: not-allowed; }
        input[type="number"] { margin: 0 5px; width: 55px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; font-size: 0.9em; }
        select { padding: 6px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; flex-grow: 1; min-width: 90px; cursor: pointer; }
        button.toggle-button { padding: 4px 8px; font-size: 0.8em; margin-left: 5px; min-width: 50px; background-color: #555; border: none; color: white; border-radius: 3px; cursor: pointer;}
        button.toggle-button.active { background-color: #4CAF50; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .sequencer-container { margin-bottom: 20px; }
        .sequencer { display: grid; grid-template-columns: repeat(var(--sequencer-steps, 16), 1fr); gap: 4px; padding: 10px; background: #2a2a2a; border-radius: 8px; }
        .step { aspect-ratio: 1; background: #333; border: none; border-radius: 4px; cursor: pointer; position: relative; min-width: 15px; }
        .step.active { background: #4CAF50; }
        .step.current { border: 2px solid white; box-shadow: 0 0 5px white; }
        .note-display { position: absolute; bottom: -16px; left: 50%; transform: translateX(-50%); font-size: 9px; color: white; white-space: nowrap; }
        .velocity-container { display: grid; grid-template-columns: repeat(var(--sequencer-steps, 16), 1fr); gap: 4px; padding: 10px; background: #2a2a2a; border-radius: 8px; margin-top: 25px; }
        .velocity-step { width: 100%; height: 25px; background: #444; border-radius: 4px; cursor: ns-resize; position: relative; min-width: 15px; }
        .velocity-step.active { background: #888; }
        .velocity-value { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10px; pointer-events: none; }
        .transport { display: flex; flex-wrap: wrap; gap: 10px; margin: 20px 0; align-items: center; }
        button { padding: 8px 15px; background: #4CAF50; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.9em; }
        button:hover:not(:disabled) { background: #45a049; }
        #bpm { width: 50px; padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        .value-display { width: 65px; text-align: right; font-size: 0.82em; margin-left: 5px; white-space: nowrap; color: #ddd; flex-shrink: 0; }
        #loadFileInput { display: none; }
        .sub-group { border-top: 1px solid #444; margin-top: 12px; padding-top: 10px; }
        .sub-group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-weight: bold; font-size: 0.9em; }
    </style>
</head>
<body>
    <header>
        <h1>Kretzonizer v3.8</h1>
        <div>Written by Jonas Lund 2025</div>
    </header>

    <div class="container">
        <!-- Controls Sections -->
        <div class="controls">
             <!-- OSC 1 -->
             <div class="control-group">
                 <div class="control-group-header">
                    <h3>Oscillator 1</h3>
                    <button id="osc1PwToggleBtn" class="toggle-button active">PW ON</button>
                 </div>
                 <div class="control-row"> <label for="waveform1">Waveform:</label> <select id="waveform1"> <option value="sawtooth" selected>Sawtooth</option> <option value="square">Square</option> <option value="pulse">Pulse</option> <option value="sine">Sine</option> <option value="triangle">Triangle</option> <option value="noise">Noise</option> </select> </div>
                 <div class="control-row"> <label for="pitch1">Pitch:</label> <input type="range" id="pitch1" min="-12" max="12" step="1" value="0"> <span class="value-display" id="pitch1Value">0 st</span> </div>
                 <div class="control-row"> <label for="detune1">Detune:</label> <input type="range" id="detune1" min="-100" max="100" step="1" value="0"> <span class="value-display" id="detune1Value">0 ct</span> </div>
                 <div class="control-row"> <label for="octave1">Octave:</label> <input type="range" id="octave1" min="-2" max="2" step="1" value="0"> <span class="value-display" id="octave1Value">0 oct</span> </div>
                 <div class="control-row"> <label for="pulseWidth1">Shape/PW:</label> <input type="range" id="pulseWidth1" min="0.01" max="0.99" step="0.01" value="0.5" disabled> <span class="value-display" id="pulseWidth1Value">0.50</span> </div>
             </div>
             <!-- OSC 2 -->
             <div class="control-group">
                  <div class="control-group-header">
                    <h3>Oscillator 2</h3>
                     <button id="osc2PwToggleBtn" class="toggle-button active">PW ON</button>
                  </div>
                 <div class="control-row"> <label for="waveform2">Waveform:</label> <select id="waveform2"> <option value="sawtooth" selected>Sawtooth</option> <option value="square">Square</option> <option value="pulse">Pulse</option> <option value="sine">Sine</option> <option value="triangle">Triangle</option> <option value="noise">Noise</option> </select> </div>
                 <div class="control-row"> <label for="pitch2">Pitch:</label> <input type="range" id="pitch2" min="-12" max="12" step="1" value="0"> <span class="value-display" id="pitch2Value">0 st</span> </div>
                 <div class="control-row"> <label for="detune2">Detune:</label> <input type="range" id="detune2" min="-100" max="100" step="1" value="10"> <span class="value-display" id="detune2Value">10 ct</span> </div>
                 <div class="control-row"> <label for="octave2">Octave:</label> <input type="range" id="octave2" min="-2" max="2" step="1" value="0"> <span class="value-display" id="octave2Value">0 oct</span> </div>
                 <div class="control-row"> <label for="pulseWidth2">Shape/PW:</label> <input type="range" id="pulseWidth2" min="0.01" max="0.99" step="0.01" value="0.5" disabled> <span class="value-display" id="pulseWidth2Value">0.50</span> </div>
             </div>
             <!-- Mixer/Master/Portamento -->
             <div class="control-group">
                 <h3>Mixer / Master</h3>
                  <div class="control-row"> <label for="oscMix">Osc Mix:</label> <input type="range" id="oscMix" min="0" max="1" step="0.01" value="0.5"> <span class="value-display" id="oscMixValue">1:1</span> </div>
                  <div class="control-row" style="font-size: 0.8em; justify-content: center; margin-top: -10px; margin-bottom: 15px;"> <span style="margin-right: 10px;">(Osc1</span><span>Osc2)</span> </div>
                  <div class="control-row"> <label for="masterVolume">Volume:</label> <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7"> <span class="value-display" id="masterVolumeValue">0.70</span> </div>
                  <div class="sub-group">
                     <div class="sub-group-header"> Portamento <button id="portaToggleBtn" class="toggle-button">OFF</button> </div>
                     <div class="control-row"> <label for="portaTime">Time:</label> <input type="range" id="portaTime" min="0.001" max="3" step="0.001" value="0.1"> <span class="value-display" id="portaTimeValue">0.100s</span> </div>
                 </div>
             </div>
             <!-- Filter -->
             <div class="control-group">
                 <div class="control-group-header">
                    <h3>Filter</h3>
                     <button id="filterEnvToggleBtn" class="toggle-button active">ENV ON</button>
                 </div>
                 <div class="control-row"> <label for="cutoff">Cutoff:</label> <input type="range" id="cutoff" min="20" max="20000" step="1" value="5000" data-log="true"> <span class="value-display" id="cutoffValue">5000 Hz</span> </div>
                 <div class="control-row"> <label for="resonance">Resonance:</label> <input type="range" id="resonance" min="0" max="30" step="0.1" value="5"> <span class="value-display" id="resonanceValue">5.0</span> </div>
                 <div class="sub-group">
                    <div class="sub-group-header">Filter Env</div>
                    <div class="control-row"> <label for="fAttack">F.Attack:</label> <input type="range" id="fAttack" min="0.001" max="2" step="0.001" value="0.1"> <span class="value-display" id="fAttackValue">0.100s</span> </div>
                    <div class="control-row"> <label for="fDecay">F.Decay:</label> <input type="range" id="fDecay" min="0.001" max="2" step="0.001" value="0.2"> <span class="value-display" id="fDecayValue">0.200s</span> </div>
                    <div class="control-row"> <label for="fSustain">F.Sustain:</label> <input type="range" id="fSustain" min="0" max="1" step="0.01" value="0.5"> <span class="value-display" id="fSustainValue">0.50</span> </div>
                    <div class="control-row"> <label for="fRelease">F.Release:</label> <input type="range" id="fRelease" min="0.001" max="4" step="0.001" value="0.5"> <span class="value-display" id="fReleaseValue">0.500s</span> </div>
                    <div class="control-row"> <label for="fAmount">F.Amount:</label> <input type="range" id="fAmount" min="-15000" max="15000" step="10" value="2000"> <span class="value-display" id="fAmountValue">2000</span> </div>
                 </div>
             </div>
             <!-- Amp Env -->
             <div class="control-group">
                 <h3>Amp Env</h3>
                 <div class="control-row"> <label for="attack">Attack:</label> <input type="range" id="attack" min="0.001" max="2" step="0.001" value="0.05"> <span class="value-display" id="attackValue">0.050s</span> </div>
                 <div class="control-row"> <label for="decay">Decay:</label> <input type="range" id="decay" min="0.001" max="2" step="0.001" value="0.1"> <span class="value-display" id="decayValue">0.100s</span> </div>
                 <div class="control-row"> <label for="sustain">Sustain:</label> <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.8"> <span class="value-display" id="sustainValue">0.80</span> </div>
                 <div class="control-row"> <label for="release">Release:</label> <input type="range" id="release" min="0.001" max="4" step="0.001" value="0.5"> <span class="value-display" id="releaseValue">0.500s</span> </div>
             </div>
             <!-- LFO -->
             <div class="control-group">
                 <div class="control-group-header">
                     <h3>LFO</h3>
                      <button id="lfoToggleBtn" class="toggle-button active">LFO ON</button>
                 </div>
                 <div class="control-row"> <label for="lfoWaveform">Waveform:</label> <select id="lfoWaveform"> <option value="sine" selected>Sine</option> <option value="square">Square</option> <option value="sawtooth">Sawtooth</option> <option value="triangle">Triangle</option> </select> </div>
                 <div class="control-row"> <label for="lfoRate">Rate:</label> <input type="range" id="lfoRate" min="0" max="30" step="0.1" value="5"> <span class="value-display" id="lfoRateValue">5.0 Hz</span> </div>
                 <div class="control-row"> <label for="lfoAmount">Amount:</label> <input type="range" id="lfoAmount" min="-7200" max="7200" step="1" value="0"> <span class="value-display" id="lfoAmountValue">0</span> </div>
                 <div class="control-row"> <label for="lfoTarget">Target:</label> <select id="lfoTarget"> <option value="off" selected>Off</option> <option value="cutoff">Filter Cutoff</option> <option value="pitch">Osc Pitch</option> <option value="pwm">Osc Shape/PW</option> <option value="mix">Osc Mix</option> <option value="volume">Volume</option> </select> </div>
             </div>
             <!-- Pitch Env -->
             <div class="control-group">
                  <div class="control-group-header">
                      <h3>Pitch Env</h3>
                       <button id="pitchEnvToggleBtn" class="toggle-button active">ENV ON</button>
                  </div>
                  <div class="control-row"> <label for="pAttack">P.Attack:</label> <input type="range" id="pAttack" min="0" max="2" step="0.001" value="0.0"> <span class="value-display" id="pAttackValue">0.000s</span> </div>
                  <div class="control-row"> <label for="pDecay">P.Decay:</label> <input type="range" id="pDecay" min="0.001" max="2" step="0.001" value="0.1"> <span class="value-display" id="pDecayValue">0.100s</span> </div>
                  <div class="control-row"> <label for="pSustain">P.Sustain:</label> <input type="range" id="pSustain" min="0" max="1" step="0.01" value="0.0"> <span class="value-display" id="pSustainValue">0.00</span> </div>
                  <div class="control-row"> <label for="pRelease">P.Release:</label> <input type="range" id="pRelease" min="0" max="2" step="0.001" value="0.0"> <span class="value-display" id="pReleaseValue">0.000s</span> </div>
                  <div class="control-row"> <label for="pAmount">P.Amount:</label> <input type="range" id="pAmount" min="-3600" max="3600" step="1" value="0"> <span class="value-display" id="pAmountValue">0 cents</span> </div>
             </div>
              <!-- Effects -->
              <div class="control-group">
                  <h3>Effects</h3>
                  <div class="sub-group" style="border-top: none; margin-top: 0; padding-top: 0;">
                      <div class="sub-group-header"> Delay <button id="delayToggleBtn" class="toggle-button active">ON</button> </div>
                      <div class="control-row">
                          <label for="delayTimeSync">Time:</label>
                          <select id="delayTimeSync" style="flex-grow: 2;">
                            <option value="1">1/1</option>
                            <option value="0.75">1/2d</option>
                            <option value="0.6667">1/2t</option>
                            <option value="0.5">1/2</option>
                            <option value="0.375">1/4d</option>
                            <option value="0.3333">1/4t</option>
                            <option value="0.25" selected>1/4</option>
                            <option value="0.1875">1/8d</option>
                            <option value="0.1667">1/8t</option>
                            <option value="0.125">1/8</option>
                            <option value="0.09375">1/16d</option>
                            <option value="0.0833">1/16t</option>
                            <option value="0.0625">1/16</option>
                            <option value="0.03125">1/32</option>
                          </select>
                      </div>
                      <div class="control-row"> <label for="delayFeedback">Feedback:</label> <input type="range" id="delayFeedback" min="0" max="0.95" step="0.01" value="0.4"> <span class="value-display" id="delayFeedbackValue">0.40</span> </div>
                      <div class="control-row"> <label for="delayMix">Mix:</label> <input type="range" id="delayMix" min="0" max="1" step="0.01" value="0.35"> <span class="value-display" id="delayMixValue">0.35</span> </div>
                      <div class="control-row"> <label>Ping-Pong:</label> <button id="delayPingPongToggleBtn" class="toggle-button">OFF</button> </div>
                  </div>
                  <div class="sub-group">
                      <div class="sub-group-header"> Reverb <button id="reverbToggleBtn" class="toggle-button active" disabled>ON</button> </div>
                      <div class="control-row"> <label for="reverbPreDelay">PreDelay:</label> <input type="range" id="reverbPreDelay" min="0" max="0.2" step="0.001" value="0.01" disabled> <span class="value-display" id="reverbPreDelayValue">0.010s</span> </div>
                       <div class="control-row"> <label for="reverbTone">Tone:</label> <input type="range" id="reverbTone" min="1000" max="20000" step="10" value="8000" data-log="true" disabled> <span class="value-display" id="reverbToneValue">8000 Hz</span> </div>
                      <div class="control-row"> <label for="reverbMix">Mix:</label> <input type="range" id="reverbMix" min="0" max="1" step="0.01" value="0.25" disabled> <span class="value-display" id="reverbMixValue">0.25</span> </div>
                       <div class="control-row" style="font-size: 0.8em; justify-content: center; color: #888;" id="reverbLoadingStatus"> Loading IR... </div>
                  </div>
              </div>
        </div>

        <!-- Transport -->
        <div class="transport">
            <button id="playBtn">Play</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="randomizeBtn">Randomize Sequencer</button>
            <button id="randomSynthBtn">Randomize Synth</button>
            <button id="savePresetBtn">Save Preset</button>
            <button id="loadPresetBtn">Load Preset</button>
            <input type="file" id="loadFileInput" accept=".skrtz,.json">
            <button id="exportWavBtn">Export to WAV</button>
            <label for="bpm">BPM: <input type="number" id="bpm" value="120" min="40" max="300"></label>
            <label for="sequencerLength">Steps: <input type="number" id="sequencerLength" value="16" min="3" max="32"></label>
        </div>
        
        <!-- Sequencer -->
        <div class="sequencer-container"> <div id="sequencer" class="sequencer"></div> </div>
        
        <!-- Velocity -->
        <div class="velocity-container" id="velocityContainer"></div>
    </div>

    <footer> <p>Kretzonizer v3.8</p> </footer>

    <script>
        function createSyntheticImpulse(ctx) {
            const sr = ctx.sampleRate;
            const dur = 1.8, dec = 2.5;
            const len = Math.ceil(sr * dur);
            if (len <= 0) return null;
            const imp = ctx.createBuffer(2, len, sr);
            const l = imp.getChannelData(0), r = imp.getChannelData(1);
            for (let i = 0; i < len; i++) {
                const n = i / len, e = Math.pow(1 - n, dec);
                l[i] = (Math.random() * 2 - 1) * e * (0.6 + Math.random() * 0.4);
                r[i] = (Math.random() * 2 - 1) * e * (0.6 + Math.random() * 0.4);
            }
            return imp;
        }

        class StepSequencer {
            constructor() {
                this.audioContext = new(window.AudioContext || window.webkitAudioContext)();
                this.isPlaying = false;
                this.currentStep = 0;
                this.sequencerLength = 16;
                this.steps = this.createDefaultSteps(this.sequencerLength);
                this.tempo = 120;
                this.stepInterval = (60 / this.tempo) / 4;
                this.notes = this.generateNotes();
                this.activeVoices = new Map();
                this.lastNoteId = 0;
                this.impulseBuffer = null;
                this.delayEnabled = true;
                this.delayPingPong = false; // New delay property
                this.reverbEnabled = true;
                this.portamentoEnabled = false;
                this.portamentoTime = 0.1;
                this.logBase = 1000;
                this.isNoteDragging = false;
                this.isVelocityDragging = false;
                this.draggedNoteIndex = -1;
                this.draggedVelocityIndex = -1;
                this.dragStartY = 0;
                this.dragStartNoteIndex = 0;
                this.dragStartVelocity = 0;
                this.osc1PwEnabled = true;
                this.osc2PwEnabled = true;
                this.lfoEnabled = true;
                this.pitchEnvEnabled = true;
                this.filterEnvEnabled = true;

                this.setupAudio();
                this.loadImpulseResponse();
                this.initializeStepsUI();
                this.initializeVelocityUI();
                this.setupControls();
                this.setupWindowListeners();
                this.updateAllDisplays();
            }

            createDefaultSteps(length) { const d = []; for (let i = 0; i < length; i++) d.push({ active: false, note: 'C3', velocity: 100 }); return d; }
            valueToLog(v, min, max) { const mnL = Math.log(min || 1) / Math.log(this.logBase); const mxL = Math.log(max) / Math.log(this.logBase); const rng = max - min; if (rng === 0) return min; const sc = (mxL - mnL) / rng; return Math.max(min, Math.min(max, Math.pow(this.logBase, mnL + sc * (v - min)))); }
            generateNotes() { const n = {}; const nn = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']; for (let o = -2; o <= 6; o++) { nn.forEach((nt, i) => { const f = 440 * Math.pow(2, ((o - 4) * 12 + i - 9) / 12); n[`${nt}${o}`] = f; }); } return n; }
            createShaperCurve(amount) { const k = typeof amount === 'number' ? amount : 0; const n = 4096; const c = new Float32Array(n); const d = Math.PI / 180; for (let i = 0; i < n; ++i) { const x = i * 2 / n - 1; c[i] = (3 + k) * x * 20 * d / (Math.PI + k * Math.abs(x)); } return c; }
            
            setupAudio() {
                this.filter = this.audioContext.createBiquadFilter();
                this.mainGain = this.audioContext.createGain();
                this.mainGain.connect(this.audioContext.destination);
                
                this.delayInputGain = this.audioContext.createGain();
                this.delayDryGain = this.audioContext.createGain();
                this.delayWetGain = this.audioContext.createGain();
                this.delaySplitter = this.audioContext.createChannelSplitter(2);
                this.delayMerger = this.audioContext.createChannelMerger(2);
                this.delayL = this.audioContext.createDelay(5.0);
                this.delayR = this.audioContext.createDelay(5.0);
                this.feedbackL = this.audioContext.createGain();
                this.feedbackR = this.audioContext.createGain();
                
                this.reverbPreDelayNode = this.audioContext.createDelay(0.5);
                this.reverbConvolver = this.audioContext.createConvolver();
                this.reverbToneFilter = this.audioContext.createBiquadFilter();
                this.reverbWetGain = this.audioContext.createGain();

                // Connect Main Signal Path
                this.filter.connect(this.delayInputGain);
                this.delayInputGain.connect(this.delayDryGain);
                this.delayInputGain.connect(this.delayWetGain);
                this.delayDryGain.connect(this.reverbPreDelayNode);
                this.delayWetGain.connect(this.delaySplitter);

                // Stereo Delay Path
                this.delaySplitter.connect(this.delayL, 0);
                this.delaySplitter.connect(this.delayR, 1);
                this.delayL.connect(this.feedbackL);
                this.delayR.connect(this.feedbackR);
                this.updateDelayRouting(); // Handles ping-pong setup
                this.delayL.connect(this.delayMerger, 0, 0);
                this.delayR.connect(this.delayMerger, 0, 1);
                this.delayMerger.connect(this.reverbPreDelayNode);

                // Reverb Path
                this.reverbPreDelayNode.connect(this.mainGain);
                this.reverbPreDelayNode.connect(this.reverbConvolver);
                this.reverbConvolver.connect(this.reverbToneFilter);
                this.reverbToneFilter.connect(this.reverbWetGain);
                this.reverbWetGain.connect(this.mainGain);

                this.updateAudioSettings();
            }
            
            updateAudioSettings() {
                this.filter.frequency.value = this.valueToLog(parseFloat(document.getElementById('cutoff').value), 20, 20000);
                this.filter.Q.value = parseFloat(document.getElementById('resonance').value);
                this.mainGain.gain.value = parseFloat(document.getElementById('masterVolume').value);
                this.reverbToneFilter.type = 'lowpass';
                this.reverbToneFilter.frequency.value = this.valueToLog(parseFloat(document.getElementById('reverbTone').value), 1000, 20000);
                this.reverbToneFilter.Q.value = 0.5;
                this.updateDelaySettings();
                this.updateReverbSettings();
            }

            loadImpulseResponse() {
                try {
                    this.impulseBuffer = createSyntheticImpulse(this.audioContext);
                    if (this.impulseBuffer) {
                        this.reverbConvolver.buffer = this.impulseBuffer;
                        document.getElementById('reverbToggleBtn').disabled = false;
                        document.getElementById('reverbMix').disabled = false;
                        document.getElementById('reverbPreDelay').disabled = false;
                        document.getElementById('reverbTone').disabled = false;
                        document.getElementById('reverbLoadingStatus').textContent = "Ready";
                        document.getElementById('reverbLoadingStatus').style.color = '#4CAF50';
                        this.updateReverbSettings();
                    }
                } catch (error) {
                    console.error("IR Error:", error);
                    document.getElementById('reverbLoadingStatus').textContent = "IR Error!";
                    document.getElementById('reverbLoadingStatus').style.color = 'red';
                    this.reverbEnabled = false;
                    const btn = document.getElementById('reverbToggleBtn');
                    btn.disabled = true; btn.classList.remove('active'); btn.textContent = 'OFF';
                    document.getElementById('reverbMix').disabled = true; document.getElementById('reverbPreDelay').disabled = true; document.getElementById('reverbTone').disabled = true;
                }
            }
            
            updateDelaySettings() {
                const now = this.audioContext.currentTime;
                const feedback = parseFloat(document.getElementById('delayFeedback').value);
                const mix = parseFloat(document.getElementById('delayMix').value);
                
                const timeValue = parseFloat(document.getElementById('delayTimeSync').value);
                const beatDuration = 60.0 / this.tempo;
                const delayTime = beatDuration * timeValue;

                this.delayL.delayTime.setTargetAtTime(delayTime, now, 0.01);
                this.delayR.delayTime.setTargetAtTime(delayTime, now, 0.01);
                this.feedbackL.gain.setTargetAtTime(feedback, now, 0.01);
                this.feedbackR.gain.setTargetAtTime(feedback, now, 0.01);
                this.delayWetGain.gain.setTargetAtTime(this.delayEnabled ? mix : 0, now, 0.01);
                this.delayDryGain.gain.setTargetAtTime(1.0 - (this.delayEnabled ? mix : 0), now, 0.01);
            }

            updateDelayRouting() {
                this.feedbackL.disconnect();
                this.feedbackR.disconnect();
                if (this.delayPingPong) {
                    this.feedbackL.connect(this.delayR);
                    this.feedbackR.connect(this.delayL);
                } else {
                    this.feedbackL.connect(this.delayL);
                    this.feedbackR.connect(this.delayR);
                }
            }

            updateReverbSettings() { const now = this.audioContext.currentTime; const preDelay = parseFloat(document.getElementById('reverbPreDelay').value); const mix = parseFloat(document.getElementById('reverbMix').value); this.reverbPreDelayNode.delayTime.setTargetAtTime(preDelay, now, 0.01); this.reverbWetGain.gain.setTargetAtTime(this.reverbEnabled && this.impulseBuffer ? mix : 0, now, 0.01); }

            initializeStepsUI() { const sequencer = document.getElementById('sequencer'); const allNotes = Object.keys(this.notes); sequencer.innerHTML = ''; sequencer.style.setProperty('--sequencer-steps', this.sequencerLength); for (let i = 0; i < this.sequencerLength; i++) { const step = document.createElement('button'); step.className = 'step'; step.dataset.index = i; const noteDisplay = document.createElement('div'); noteDisplay.className = 'note-display'; step.appendChild(noteDisplay); step.addEventListener('mousedown', (e) => { if (e.button !== 0) return; const idx = parseInt(e.currentTarget.dataset.index); if (!this.steps[idx].active) { this.steps[idx].active = true; e.currentTarget.classList.add('active'); this.updateNoteDisplay(idx); } this.isNoteDragging = true; this.draggedNoteIndex = idx; this.dragStartY = e.clientY; if (!this.steps[idx].note) this.steps[idx].note = 'C3'; this.dragStartNoteIndex = allNotes.indexOf(this.steps[idx].note); e.preventDefault(); }); step.addEventListener('contextmenu', (e) => { e.preventDefault(); const idx = parseInt(e.currentTarget.dataset.index); this.steps[idx].active = false; e.currentTarget.classList.remove('active'); this.updateNoteDisplay(idx); }); step.addEventListener('dblclick', (e) => { e.preventDefault(); const idx = parseInt(e.currentTarget.dataset.index); this.steps[idx].active = !this.steps[idx].active; e.currentTarget.classList.toggle('active'); this.updateNoteDisplay(idx); }); sequencer.appendChild(step); this.updateNoteDisplay(i); } }
            initializeVelocityUI() { const velContainer = document.getElementById('velocityContainer'); velContainer.innerHTML = ''; velContainer.style.setProperty('--sequencer-steps', this.sequencerLength); for (let i = 0; i < this.sequencerLength; i++) { const velStep = document.createElement('div'); velStep.className = 'velocity-step'; velStep.dataset.index = i; const velValue = document.createElement('div'); velValue.className = 'velocity-value'; velStep.appendChild(velValue); const updateVelDisplay = () => { if (this.steps[i]) velValue.textContent = String(this.steps[i].velocity); }; velStep.addEventListener('mousedown', (e) => { if (e.button !== 0) return; const idx = parseInt(e.currentTarget.dataset.index); this.isVelocityDragging = true; this.draggedVelocityIndex = idx; this.dragStartY = e.clientY; this.dragStartVelocity = this.steps[i].velocity; e.currentTarget.classList.add('active'); e.preventDefault(); }); velContainer.appendChild(velStep); updateVelDisplay(); } }
            setupWindowListeners() { document.addEventListener('mousemove', (e) => { if (this.isNoteDragging && this.draggedNoteIndex >= 0) { const i = this.draggedNoteIndex; const allNotes = Object.keys(this.notes); const dy = this.dragStartY - e.clientY; const stepsMoved = Math.floor(dy / 8); let newIndex = this.dragStartNoteIndex + stepsMoved; newIndex = Math.max(0, Math.min(newIndex, allNotes.length - 1)); if (this.steps[i].note !== allNotes[newIndex]) { this.steps[i].note = allNotes[newIndex]; this.updateNoteDisplay(i); } } else if (this.isVelocityDragging && this.draggedVelocityIndex >= 0) { const i = this.draggedVelocityIndex; const dy = this.dragStartY - e.clientY; const offset = Math.floor(dy / 1.5); let newVelocity = this.dragStartVelocity + offset; newVelocity = Math.max(0, Math.min(127, newVelocity)); if (this.steps[i].velocity !== newVelocity) { this.steps[i].velocity = newVelocity; const velStep = document.querySelector(`.velocity-step[data-index='${i}']`); const velValue = velStep?.querySelector('.velocity-value'); if (velValue) velValue.textContent = String(newVelocity); } } }); window.addEventListener('mouseup', (e) => { if (e.button === 0) { if (this.isNoteDragging) { this.isNoteDragging = false; this.draggedNoteIndex = -1; } if (this.isVelocityDragging) { this.isVelocityDragging = false; const velStep = document.querySelector(`.velocity-step[data-index='${this.draggedVelocityIndex}']`); if (velStep) velStep.classList.remove('active'); this.draggedVelocityIndex = -1; } } }); document.addEventListener('contextmenu', (e) => { if (this.isNoteDragging || this.isVelocityDragging) e.preventDefault(); }); }
            
            redrawSequencerUI() { for (let i = 0; i < this.sequencerLength; i++) { this.updateNoteDisplay(i); } }
            redrawVelocityUI() { const velSteps = document.querySelectorAll('#velocityContainer .velocity-step'); for (let i = 0; i < this.sequencerLength; i++) { const velValue = velSteps[i]?.querySelector('.velocity-value'); if (velValue && this.steps[i]) { velValue.textContent = String(this.steps[i].velocity); } } }
            updateNoteDisplay(idx) { const stepEl = document.querySelector(`.step[data-index='${idx}']`); if (!stepEl || !this.steps[idx]) return; const noteDisplay = stepEl.querySelector('.note-display'); const { active, note } = this.steps[idx]; if (noteDisplay) noteDisplay.textContent = (active && note) ? note : (note ? `(${note})` : ''); stepEl.classList.toggle('active', active); }
            updateDisplay(id, val, unit = '', dp = 2) { const display = document.getElementById(id); if (!display) return; let value = Number(val); if (unit === ' Hz') { if (value >= 1000) display.textContent = `${(value / 1000).toFixed(1)} kHz`; else display.textContent = `${value.toFixed(0)}${unit}`; } else if (typeof val === 'string' && unit === '') { display.textContent = val; } else { display.textContent = `${value.toFixed(dp)}${unit}`; } }
            
            updateAllDisplays() {
                const elements = [
                    { id: 'pitch1', display: 'pitch1Value', unit: ' st', decimals: 0 }, { id: 'detune1', display: 'detune1Value', unit: ' ct', decimals: 0 }, { id: 'octave1', display: 'octave1Value', unit: ' oct', decimals: 0 }, { id: 'pulseWidth1', display: 'pulseWidth1Value', unit: '', decimals: 2 },
                    { id: 'pitch2', display: 'pitch2Value', unit: ' st', decimals: 0 }, { id: 'detune2', display: 'detune2Value', unit: ' ct', decimals: 0 }, { id: 'octave2', display: 'octave2Value', unit: ' oct', decimals: 0 }, { id: 'pulseWidth2', display: 'pulseWidth2Value', unit: '', decimals: 2 },
                    { id: 'oscMix', display: 'oscMixValue', format: (v) => `${Math.round((1 - v) * 10)}:${Math.round(v * 10)}` },
                    { id: 'masterVolume', display: 'masterVolumeValue', unit: '', decimals: 2 }, { id: 'portaTime', display: 'portaTimeValue', unit: 's', decimals: 3 },
                    { id: 'cutoff', display: 'cutoffValue', unit: ' Hz', decimals: 0 }, { id: 'resonance', display: 'resonanceValue', unit: '', decimals: 1 },
                    { id: 'fAttack', display: 'fAttackValue', unit: 's', decimals: 3 }, { id: 'fDecay', display: 'fDecayValue', unit: 's', decimals: 3 }, { id: 'fSustain', display: 'fSustainValue', unit: '', decimals: 2 }, { id: 'fRelease', display: 'fReleaseValue', unit: 's', decimals: 3 }, { id: 'fAmount', display: 'fAmountValue', unit: '', decimals: 0 },
                    { id: 'attack', display: 'attackValue', unit: 's', decimals: 3 }, { id: 'decay', display: 'decayValue', unit: 's', decimals: 3 }, { id: 'sustain', display: 'sustainValue', unit: '', decimals: 2 }, { id: 'release', display: 'releaseValue', unit: 's', decimals: 3 },
                    { id: 'lfoRate', display: 'lfoRateValue', unit: ' Hz', decimals: 1 }, { id: 'lfoAmount', display: 'lfoAmountValue', unit: '', decimals: 0 },
                    { id: 'pAttack', display: 'pAttackValue', unit: 's', decimals: 3 }, { id: 'pDecay', display: 'pDecayValue', unit: 's', decimals: 3 }, { id: 'pSustain', display: 'pSustainValue', unit: '', decimals: 2 }, { id: 'pRelease', display: 'pReleaseValue', unit: 's', decimals: 3 }, { id: 'pAmount', display: 'pAmountValue', unit: ' cents', decimals: 0 },
                    { id: 'delayFeedback', display: 'delayFeedbackValue', unit: '', decimals: 2 }, { id: 'delayMix', display: 'delayMixValue', unit: '', decimals: 2 },
                    { id: 'reverbPreDelay', display: 'reverbPreDelayValue', unit: 's', decimals: 3 }, { id: 'reverbTone', display: 'reverbToneValue', unit: ' Hz', decimals: 0 }, { id: 'reverbMix', display: 'reverbMixValue', unit: '', decimals: 2 },
                ];
                elements.forEach(elInfo => { const input = document.getElementById(elInfo.id); if (input) { const value = parseFloat(input.value); if (elInfo.format) { const display = document.getElementById(elInfo.display); if (display) display.textContent = elInfo.format(value); } else if (elInfo.display) { this.updateDisplay(elInfo.display, value, elInfo.unit, elInfo.decimals); } } });
                
                const updateToggleBtn = (id, isActive, textPrefix = '') => { const btn = document.getElementById(id); if (btn) { btn.classList.toggle('active', isActive); btn.textContent = `${textPrefix}${isActive ? 'ON' : 'OFF'}`; } };
                updateToggleBtn('delayToggleBtn', this.delayEnabled);
                updateToggleBtn('delayPingPongToggleBtn', this.delayPingPong, 'P-PONG ');
                updateToggleBtn('reverbToggleBtn', this.reverbEnabled && this.impulseBuffer && !document.getElementById('reverbToggleBtn').disabled);
                updateToggleBtn('portaToggleBtn', this.portamentoEnabled);
                updateToggleBtn('osc1PwToggleBtn', this.osc1PwEnabled, 'PW ');
                updateToggleBtn('osc2PwToggleBtn', this.osc2PwEnabled, 'PW ');
                updateToggleBtn('lfoToggleBtn', this.lfoEnabled, 'LFO ');
                updateToggleBtn('pitchEnvToggleBtn', this.pitchEnvEnabled, 'ENV ');
                updateToggleBtn('filterEnvToggleBtn', this.filterEnvEnabled, 'ENV ');
            }
            
            setupControls() {
                const setupToggle = (id, propertyName, updateFn = null) => { const btn = document.getElementById(id); if (btn) { btn.addEventListener('click', () => { this[propertyName] = !this[propertyName]; if (updateFn) this[updateFn](); this.updateAllDisplays(); }); } };
                const setupParam = (id, updateFn = null) => { const el = document.getElementById(id); if (el) { const eventType = el.tagName === 'SELECT' ? 'change' : 'input'; el.addEventListener(eventType, () => { this.updateAllDisplays(); if (updateFn) updateFn(); }); } };
                
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('randomizeBtn').addEventListener('click', () => this.randomizeSteps());
                document.getElementById('randomSynthBtn').addEventListener('click', () => this.randomizeSynth());
                document.getElementById('exportWavBtn').addEventListener('click', () => this.exportToWav());
                document.getElementById('savePresetBtn').addEventListener('click', () => this.savePreset());
                document.getElementById('loadPresetBtn').addEventListener('click', () => document.getElementById('loadFileInput').click());
                document.getElementById('loadFileInput').addEventListener('change', (e) => this.handleFileLoad(e));
                document.getElementById('bpm').addEventListener('change', () => { this.tempo = parseInt(document.getElementById('bpm').value) || 120; this.stepInterval = (60 / this.tempo) / 4; this.updateDelaySettings(); if (this.isPlaying) { this.stop(); this.play(); } });
                document.getElementById('sequencerLength').addEventListener('change', (e) => this.setSequencerLength(parseInt(e.target.value)));
                
                const paramIds = ['pitch1', 'detune1', 'octave1', 'pulseWidth1', 'pitch2', 'detune2', 'octave2', 'pulseWidth2', 'oscMix', 'lfoWaveform', 'lfoRate', 'lfoAmount', 'lfoTarget', 'attack', 'decay', 'sustain', 'release', 'fAttack', 'fDecay', 'fSustain', 'fRelease', 'fAmount', 'pAttack', 'pDecay', 'pSustain', 'pRelease', 'pAmount'];
                paramIds.forEach(id => setupParam(id));
                
                setupParam('waveform1', () => this._updatePwSliderState(1));
                setupParam('waveform2', () => this._updatePwSliderState(2));
                setupParam('masterVolume', () => { this.mainGain.gain.value = parseFloat(document.getElementById('masterVolume').value); });
                setupParam('portaTime', () => { this.portamentoTime = parseFloat(document.getElementById('portaTime').value); });
                setupParam('cutoff', () => { this.filter.frequency.value = this.valueToLog(parseFloat(document.getElementById('cutoff').value), 20, 20000); });
                setupParam('resonance', () => { this.filter.Q.value = parseFloat(document.getElementById('resonance').value); });
                
                setupParam('delayTimeSync', () => this.updateDelaySettings());
                setupParam('delayFeedback', () => this.updateDelaySettings());
                setupParam('delayMix', () => this.updateDelaySettings());
                setupParam('reverbPreDelay', () => this.updateReverbSettings());
                setupParam('reverbTone', () => { this.reverbToneFilter.frequency.value = this.valueToLog(parseFloat(document.getElementById('reverbTone').value), 1000, 20000); });
                setupParam('reverbMix', () => this.updateReverbSettings());
                
                setupToggle('osc1PwToggleBtn', 'osc1PwEnabled');
                setupToggle('osc2PwToggleBtn', 'osc2PwEnabled');
                setupToggle('portaToggleBtn', 'portamentoEnabled');
                setupToggle('lfoToggleBtn', 'lfoEnabled');
                setupToggle('filterEnvToggleBtn', 'filterEnvEnabled');
                setupToggle('pitchEnvToggleBtn', 'pitchEnvEnabled');
                setupToggle('delayToggleBtn', 'delayEnabled', 'updateDelaySettings');
                setupToggle('delayPingPongToggleBtn', 'delayPingPong', 'updateDelayRouting');
                setupToggle('reverbToggleBtn', 'reverbEnabled', 'updateReverbSettings');
                
                this._updatePwSliderState(1);
                this._updatePwSliderState(2);
            }
            
            _updatePwSliderState(oscNum) {
                const waveform = document.getElementById(`waveform${oscNum}`).value;
                const pwSlider = document.getElementById(`pulseWidth${oscNum}`);
                const pwApplicable = ['pulse', 'square', 'sine'].includes(waveform);
                pwSlider.disabled = !pwApplicable;
            }

            play() { if (this.isPlaying) return; if (this.audioContext.state === 'suspended') { this.audioContext.resume().then(() => { console.log("AudioContext resumed."); this.startPlayback(); }).catch(e => console.error("AudioContext resume failed:", e)); } else { this.startPlayback(); } }
            startPlayback() { if (this.isPlaying) return; this.isPlaying = true; this.currentStep = 0; this.nextStepTime = this.audioContext.currentTime + 0.1; this.scheduler(); document.getElementById('playBtn').textContent = '...Playing'; document.getElementById('stopBtn').disabled = false; document.getElementById('playBtn').disabled = true; }
            stop() { if (!this.isPlaying) return; this.isPlaying = false; if (this.timerID) { clearTimeout(this.timerID); this.timerID = null; } this.stopAllNotes(); document.querySelectorAll('.step.current').forEach(s => s.classList.remove('current')); document.getElementById('playBtn').textContent = 'Play'; document.getElementById('stopBtn').disabled = true; document.getElementById('playBtn').disabled = false; this.currentStep = 0; }

            stopAllNotes() {
                this.activeVoices.forEach((voice) => {
                    const now = this.audioContext.currentTime;
                    voice.ampGain.gain.cancelScheduledValues(now);
                    voice.ampGain.gain.setTargetAtTime(0, now, 0.015);
                    voice.nodes.forEach(node => node.stop?.(now + 0.1));
                });
                this.activeVoices.clear();
            }

            nextStepTime = 0.0;
            timerID = null;
            scheduler() { if (!this.isPlaying) return; const lookahead = 0.2; while (this.nextStepTime < this.audioContext.currentTime + lookahead) { this.scheduleStep(this.currentStep, this.nextStepTime); this.nextStepTime += this.stepInterval; this.currentStep = (this.currentStep + 1) % this.sequencerLength; } this.timerID = setTimeout(() => this.scheduler(), 50); }
            scheduleStep(idx, time) { const visualDelay = Math.max(0, (time - this.audioContext.currentTime) * 1000); setTimeout(() => { if (!this.isPlaying) return; const steps = document.querySelectorAll('.step'); steps.forEach(el => el.classList.remove('current')); if (steps[idx]) steps[idx].classList.add('current'); }, visualDelay); const stepData = this.steps[idx]; if (stepData?.active && stepData.note && stepData.velocity > 0) { this.playNote(stepData.note, stepData.velocity, time); } }

            playNote(noteKey, velocity, time) {
                const params = this.gatherState();
                const noteId = this.lastNoteId++;

                let lastFreqsForGlide = { osc1: null, osc2: null };
                if (this.portamentoEnabled && this.activeVoices.size > 0) {
                    const lastVoiceKey = Math.max(...this.activeVoices.keys());
                    const lastVoice = this.activeVoices.get(lastVoiceKey);
                    if (lastVoice) {
                        lastFreqsForGlide = lastVoice.finalFreqs;
                    }
                }
                
                const { voice, fq1, fq2 } = this._createNoteVoice(this.audioContext, this.filter, time, noteKey, velocity, lastFreqsForGlide, params);
                
                if(voice) {
                    voice.finalFreqs = { osc1: fq1, osc2: fq2 };
                    this.activeVoices.set(noteId, voice);
                    
                    const totalEnvelopeDuration = params.ampEnv.attack + params.ampEnv.decay + params.ampEnv.release;
                    const cleanupDelay = (totalEnvelopeDuration * 1000) + 200;
                    
                    setTimeout(() => {
                        voice.nodes.forEach(node => node.disconnect?.());
                        this.activeVoices.delete(noteId);
                    }, cleanupDelay);
                }
            }

            _createNoteVoice(context, destinationNode, time, noteKey, velocity, lastFreqs, params) {
                const now = time;
                const baseFreqRaw = this.notes[noteKey];
                if (!baseFreqRaw) return { voice: null, fq1: null, fq2: null };
            
                const p = params;
                const ctm = (c) => Math.pow(2, c / 1200);
                const stm = (st) => Math.pow(2, st / 12);
            
                const fq1 = baseFreqRaw * Math.pow(2, p.osc1.octave) * ctm(p.osc1.detune) * stm(p.osc1.pitch);
                const fq2 = baseFreqRaw * Math.pow(2, p.osc2.octave) * ctm(p.osc2.detune) * stm(p.osc2.pitch);
                
                let nodes = [];
                let voiceOscs = {};
            
                const releaseTime = p.ampEnv.release;
                const stopTime = now + p.ampEnv.attack + p.ampEnv.decay + releaseTime + 0.1;

                let noteLfo, noteLfoGain;
                if (p.lfo.enabled && p.lfo.target !== 'off' && p.lfo.amount !== 0) {
                    noteLfo = context.createOscillator(); noteLfoGain = context.createGain();
                    noteLfo.type = p.lfo.waveform; noteLfo.frequency.setValueAtTime(p.lfo.rate, now); noteLfoGain.gain.setValueAtTime(p.lfo.amount, now);
                    noteLfo.connect(noteLfoGain); noteLfo.start(now); noteLfo.stop(stopTime); nodes.push(noteLfo, noteLfoGain);
                }
            
                const vf = velocity / 127;
                
                const portaTime = p.portamento.enabled ? Math.max(0.001, p.portamento.time) : 0;
                const glide = p.portamento.enabled && lastFreqs.osc1 !== null && lastFreqs.osc1 > 0;
                const startFreq1 = glide ? lastFreqs.osc1 : fq1;
                const startFreq2 = glide ? lastFreqs.osc2 : fq2;
                const pitchEnvStartTime = now + (glide ? portaTime : 0);
                
                const ampGain = context.createGain();
                ampGain.connect(destinationNode);
                nodes.push(ampGain);
                this.applyEnvelope(ampGain.gain, 0, vf, p.ampEnv.sustain * vf, p.ampEnv.attack, p.ampEnv.decay, releaseTime, now);
                
                const createOsc = (oscParams, targetFreq, startFreq) => {
                    const waveform = oscParams.waveform;
                    let oscNodes = {};
                    const volumeCompensations = { sawtooth: 0.65, square: 0.5, pulse: 0.5, sine: 1.0, triangle: 0.8, noise: 0.3 };
                    const compensationGain = context.createGain();
                    compensationGain.gain.value = volumeCompensations[waveform] || 1.0;
                    compensationGain.connect(ampGain);
                    nodes.push(compensationGain);
                    
                    const oscGain = context.createGain(); oscGain.gain.value = oscParams.id === 1 ? (1.0 - p.mixer.oscMix) : p.mixer.oscMix;
                    oscGain.connect(compensationGain);
                    nodes.push(oscGain);

                    const pwSim = oscParams.pwEnabled && (waveform === 'pulse' || waveform === 'square');
                    const shaperActive = oscParams.pwEnabled && waveform === 'sine';

                    if (waveform === 'noise') {
                        let nS = context.createBufferSource(); nS.buffer = createOfflineNoiseBuffer(context); nS.loop = true; nS.start(now); nS.stop(stopTime); nS.connect(oscGain);
                        nodes.push(nS);
                        oscNodes.main = nS;
                    } else if (pwSim) {
                        const oa = context.createOscillator(); oa.type = 'sawtooth'; const ob = context.createOscillator(); ob.type = 'sawtooth'; const inv = context.createGain(); inv.gain.value = -1; const pwd = context.createDelay(1.0); const period = 1 / targetFreq; let dt = Math.max(0.01, Math.min(0.99, oscParams.pulseWidth)) * period; pwd.delayTime.setValueAtTime(Math.max(1e-5, dt), now);
                        oa.frequency.setValueAtTime(startFreq, now); ob.frequency.setValueAtTime(startFreq, now); if (glide) { oa.frequency.exponentialRampToValueAtTime(targetFreq, now + portaTime); ob.frequency.exponentialRampToValueAtTime(targetFreq, now + portaTime); }
                        oa.connect(oscGain); ob.connect(inv); inv.connect(pwd); pwd.connect(oscGain); oa.start(now); oa.stop(stopTime); ob.start(now); ob.stop(stopTime);
                        nodes.push(oa, ob, inv, pwd);
                        oscNodes = { main: [oa, ob], frequency: [oa.frequency, ob.frequency], pwmDelay: pwd };
                    } else {
                        let bO = context.createOscillator(); bO.type = waveform;
                        bO.frequency.setValueAtTime(startFreq, now); if (glide) { bO.frequency.exponentialRampToValueAtTime(targetFreq, now + portaTime); }
                        if (shaperActive) { const sh = context.createWaveShaper(); sh.curve = this.createShaperCurve((oscParams.pulseWidth - 0.5) * 5); bO.connect(sh); sh.connect(oscGain); nodes.push(sh); }
                        else { bO.connect(oscGain); }
                        bO.start(now); bO.stop(stopTime); nodes.push(bO);
                        oscNodes = { main: bO, frequency: bO.frequency };
                    }
                    return oscNodes;
                };

                voiceOscs.osc1 = createOsc({ ...p.osc1, id: 1 }, fq1, startFreq1);
                voiceOscs.osc2 = createOsc({ ...p.osc2, id: 2 }, fq2, startFreq2);

                if (p.pitchEnv.enabled) { const applyPEnv = (freqParam, base, amt, sus) => { if (!freqParam) return; const peak = base * ctm(amt); const sustain = base * ctm(amt * sus); if (Array.isArray(freqParam)) { freqParam.forEach(fp => this.applyEnvelope(fp, base, peak, sustain, p.pitchEnv.attack, p.pitchEnv.decay, p.pitchEnv.release, pitchEnvStartTime)); } else { this.applyEnvelope(freqParam, base, peak, sustain, p.pitchEnv.attack, p.pitchEnv.decay, p.pitchEnv.release, pitchEnvStartTime); } }; applyPEnv(voiceOscs.osc1.frequency, fq1, p.pitchEnv.amount, p.pitchEnv.sustain); applyPEnv(voiceOscs.osc2.frequency, fq2, p.pitchEnv.amount, p.pitchEnv.sustain); }
                if (p.filter.envEnabled && destinationNode instanceof BiquadFilterNode) { const baseCutoff = this.valueToLog(p.filter.cutoff, 20, 20000); const fmf = context.sampleRate / 2; const fpk = Math.max(20, Math.min(fmf, baseCutoff + p.filterEnv.amount)); const fsus = Math.max(20, Math.min(fmf, baseCutoff + p.filterEnv.amount * p.filterEnv.sustain)); this.applyEnvelope(destinationNode.frequency, baseCutoff, fpk, fsus, p.filterEnv.attack, p.filterEnv.decay, p.filterEnv.release, now); }
                if (noteLfoGain) { const connectLfoToPitch = (freqParam) => { if(!freqParam) return; if(Array.isArray(freqParam)) freqParam.forEach(fp => noteLfoGain.connect(fp)); else noteLfoGain.connect(freqParam); }; if (p.lfo.target === 'pitch') { connectLfoToPitch(voiceOscs.osc1.frequency); connectLfoToPitch(voiceOscs.osc2.frequency); } else if (p.lfo.target === 'cutoff' && destinationNode.frequency) { noteLfoGain.connect(destinationNode.frequency); } else if (p.lfo.target === 'pwm') { if(voiceOscs.osc1.pwmDelay) { const sf1 = (1 / fq1 / 4) / 7200; const sc1 = context.createGain(); sc1.gain.value = sf1; noteLfoGain.connect(sc1); sc1.connect(voiceOscs.osc1.pwmDelay.delayTime); nodes.push(sc1); } if(voiceOscs.osc2.pwmDelay) { const sf2 = (1 / fq2 / 4) / 7200; const sc2 = context.createGain(); sc2.gain.value = sf2; noteLfoGain.connect(sc2); sc2.connect(voiceOscs.osc2.pwmDelay.delayTime); nodes.push(sc2); } } }
                
                const voice = { ampGain, nodes, releaseTime, finalFreqs: { osc1: fq1, osc2: fq2 } };
                return { voice, fq1, fq2 };
            }

            applyEnvelope(param, baseValue, peakValue, sustainValue, attack, decay, release, time) { if (!(param instanceof AudioParam)) return; param.cancelScheduledValues(time); param.setValueAtTime(baseValue, time); param.linearRampToValueAtTime(peakValue, time + attack); param.linearRampToValueAtTime(sustainValue, time + attack + decay); param.setValueAtTime(sustainValue, time + attack + decay); param.linearRampToValueAtTime(baseValue, time + attack + decay + release); }
            
            randomizeSteps() { const allNotes = Object.keys(this.notes); for (let i = 0; i < this.sequencerLength; i++) { const step = this.steps[i]; step.active = Math.random() > 0.4; if (step.active) { step.note = allNotes[Math.floor(Math.random() * allNotes.length)]; } else if (!step.note) { step.note = allNotes[Math.floor(Math.random() * allNotes.length)]; } step.velocity = Math.floor(Math.random() * 100 + 28); } this.redrawSequencerUI(); this.redrawVelocityUI(); }
            randomizeSynth() { const rf = (mn, mx) => Math.random() * (mx - mn) + mn; const ri = (mn, mx) => Math.floor(rf(mn, mx + 1)); const ss = (id, v) => { const e = document.getElementById(id); if (e) e.value = v; }; const sl = (id, v) => { const e = document.getElementById(id); if (e) e.value = v; }; const st = (id, state) => { const b = document.getElementById(id); if (b) { const isActive = b.classList.contains('active'); if (state !== isActive && !b.disabled) b.click(); } }; const waves = ['sawtooth', 'square', 'pulse', 'sine', 'triangle', 'noise']; sl('waveform1', waves[ri(0, waves.length - 1)]); ss('pitch1', ri(-7, 7)); ss('detune1', ri(-50, 50)); ss('octave1', ri(-1, 1)); ss('pulseWidth1', rf(0.1, 0.9).toFixed(2)); st('osc1PwToggleBtn', Math.random() > 0.2); sl('waveform2', waves[ri(0, waves.length - 1)]); ss('pitch2', ri(-7, 7)); ss('detune2', ri(-50, 50)); ss('octave2', ri(-1, 1)); ss('pulseWidth2', rf(0.1, 0.9).toFixed(2)); st('osc2PwToggleBtn', Math.random() > 0.2); ss('oscMix', rf(0, 1).toFixed(2)); const lfoWaves = ['sine', 'square', 'sawtooth', 'triangle']; sl('lfoWaveform', lfoWaves[ri(0, lfoWaves.length - 1)]); ss('lfoRate', rf(0.1, 20).toFixed(1)); ss('lfoAmount', ri(-6000, 6000)); const tgts = ['off', 'cutoff', 'pitch', 'pwm', 'mix', 'volume']; sl('lfoTarget', tgts[ri(0, tgts.length - 1)]); st('lfoToggleBtn', Math.random() > 0.3); ss('masterVolume', rf(0.4, 0.9).toFixed(2)); st('portaToggleBtn', Math.random() > 0.7); ss('portaTime', rf(0, 0.3).toFixed(3)); ss('cutoff', ri(100, 18000)); ss('resonance', rf(0, 25).toFixed(1)); st('filterEnvToggleBtn', Math.random() > 0.1); const re = (a, d, s, r, mT = 1.5) => { ss(a, rf(0.001, mT * 0.4).toFixed(3)); ss(d, rf(0.01, mT).toFixed(3)); ss(s, rf(0, 1).toFixed(2)); ss(r, rf(0.05, mT * 1.5).toFixed(3)); }; re('attack', 'decay', 'sustain', 'release', 2.0); re('fAttack', 'fDecay', 'fSustain', 'fRelease'); ss('fAmount', ri(-12000, 12000)); re('pAttack', 'pDecay', 'pSustain', 'pRelease', 0.6); ss('pAmount', ri(-2400, 2400)); st('pitchEnvToggleBtn', Math.random() > 0.2); st('delayToggleBtn', Math.random() > 0.3); st('delayPingPongToggleBtn', Math.random() > 0.5); st('reverbToggleBtn', Math.random() > 0.4); sl('delayTimeSync', document.getElementById('delayTimeSync').options[ri(0, 13)].value); ss('delayFeedback', rf(0, 0.85).toFixed(2)); ss('delayMix', rf(0, 0.6).toFixed(2)); if (!document.getElementById('reverbToggleBtn').disabled) { ss('reverbPreDelay', rf(0, 0.15).toFixed(3)); ss('reverbTone', ri(1500, 15000)); ss('reverbMix', rf(0, 0.5).toFixed(2)); } document.querySelectorAll('input, select').forEach(el => el.dispatchEvent(new Event('input', {bubbles: true}))); }
            gatherState() { return { version: "3.8", sequencerLength: this.sequencerLength, osc1: { waveform: document.getElementById('waveform1').value, pitch: parseFloat(document.getElementById('pitch1').value), detune: parseFloat(document.getElementById('detune1').value), octave: parseInt(document.getElementById('octave1').value), pulseWidth: parseFloat(document.getElementById('pulseWidth1').value), pwEnabled: this.osc1PwEnabled }, osc2: { waveform: document.getElementById('waveform2').value, pitch: parseFloat(document.getElementById('pitch2').value), detune: parseFloat(document.getElementById('detune2').value), octave: parseInt(document.getElementById('octave2').value), pulseWidth: parseFloat(document.getElementById('pulseWidth2').value), pwEnabled: this.osc2PwEnabled }, mixer: { oscMix: parseFloat(document.getElementById('oscMix').value) }, master: { volume: parseFloat(document.getElementById('masterVolume').value) }, portamento: { enabled: this.portamentoEnabled, time: this.portamentoTime }, filter: { cutoff: parseFloat(document.getElementById('cutoff').value), resonance: parseFloat(document.getElementById('resonance').value), envEnabled: this.filterEnvEnabled }, ampEnv: { attack: parseFloat(document.getElementById('attack').value), decay: parseFloat(document.getElementById('decay').value), sustain: parseFloat(document.getElementById('sustain').value), release: parseFloat(document.getElementById('release').value) }, filterEnv: { attack: parseFloat(document.getElementById('fAttack').value), decay: parseFloat(document.getElementById('fDecay').value), sustain: parseFloat(document.getElementById('fSustain').value), release: parseFloat(document.getElementById('fRelease').value), amount: parseFloat(document.getElementById('fAmount').value) }, pitchEnv: { enabled: this.pitchEnvEnabled, attack: parseFloat(document.getElementById('pAttack').value), decay: parseFloat(document.getElementById('pDecay').value), sustain: parseFloat(document.getElementById('pSustain').value), release: parseFloat(document.getElementById('pRelease').value), amount: parseFloat(document.getElementById('pAmount').value) }, lfo: { enabled: this.lfoEnabled, waveform: document.getElementById('lfoWaveform').value, rate: parseFloat(document.getElementById('lfoRate').value), amount: parseFloat(document.getElementById('lfoAmount').value), target: document.getElementById('lfoTarget').value }, effects: { delay: { enabled: this.delayEnabled, timeSync: document.getElementById('delayTimeSync').value, feedback: parseFloat(document.getElementById('delayFeedback').value), mix: parseFloat(document.getElementById('delayMix').value), pingPong: this.delayPingPong }, reverb: { enabled: this.reverbEnabled, preDelay: parseFloat(document.getElementById('reverbPreDelay').value), tone: parseFloat(document.getElementById('reverbTone').value), mix: parseFloat(document.getElementById('reverbMix').value) } }, transport: { bpm: parseInt(document.getElementById('bpm').value) }, steps: JSON.parse(JSON.stringify(this.steps)) }; }
            savePreset() { const state = this.gatherState(); try { const json = JSON.stringify(state, null, 2); const blob = new Blob([json], { type: "application/json" }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); const timestamp = new Date().toISOString().slice(0, 19).replace(/[-T:]/g, ""); link.href = url; link.download = `kretzonizer_${timestamp}.skrtz`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); } catch (e) { console.error("Save Error:", e); alert("Failed to save preset."); } }
            handleFileLoad(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const state = JSON.parse(e.target.result); this.applyState(state); event.target.value = null; } catch (err) { console.error("Load Error:", err); alert(`Failed to load preset: ${err.message}`); event.target.value = null; } }; reader.onerror = () => { alert("Failed to read the file."); event.target.value = null; }; reader.readAsText(file); }
            applyState(state) {
                if (!state || typeof state !== 'object') { console.error("Invalid preset data."); return; }
                const ss = (id, v) => { const e = document.getElementById(id); if (e && v != null) e.value = v; };
                const sl = (id, v) => { const e = document.getElementById(id); if (e && v != null) e.value = v; };
                const st = (id, en, prop) => { if (this[prop] !== en && document.getElementById(id)) document.getElementById(id).click(); };
                const s = state;
                if(s.osc1) { sl('waveform1', s.osc1.waveform); ss('pitch1', s.osc1.pitch ?? 0); ss('detune1', s.osc1.detune ?? 0); ss('octave1', s.osc1.octave ?? 0); ss('pulseWidth1', s.osc1.pulseWidth ?? 0.5); st('osc1PwToggleBtn', s.osc1.pwEnabled ?? true, 'osc1PwEnabled'); }
                if(s.osc2) { sl('waveform2', s.osc2.waveform); ss('pitch2', s.osc2.pitch ?? 0); ss('detune2', s.osc2.detune ?? 0); ss('octave2', s.osc2.octave ?? 0); ss('pulseWidth2', s.osc2.pulseWidth ?? 0.5); st('osc2PwToggleBtn', s.osc2.pwEnabled ?? true, 'osc2PwEnabled'); }
                if(s.mixer) ss('oscMix', s.mixer.oscMix);
                if(s.master) ss('masterVolume', s.master.volume);
                if(s.filter) { ss('cutoff', s.filter.cutoff); ss('resonance', s.filter.resonance); st('filterEnvToggleBtn', s.filter.envEnabled ?? true, 'filterEnvEnabled'); }
                if(s.ampEnv) { ss('attack', s.ampEnv.attack); ss('decay', s.ampEnv.decay); ss('sustain', s.ampEnv.sustain); ss('release', s.ampEnv.release); }
                if(s.filterEnv) { ss('fAttack', s.filterEnv.attack); ss('fDecay', s.filterEnv.decay); ss('fSustain', s.filterEnv.sustain); ss('fRelease', s.filterEnv.release); ss('fAmount', s.filterEnv.amount); }
                if(s.pitchEnv) { ss('pAttack', s.pitchEnv.attack); ss('pDecay', s.pitchEnv.decay); ss('pSustain', s.pitchEnv.sustain); ss('pRelease', s.pitchEnv.release); ss('pAmount', s.pitchEnv.amount); st('pitchEnvToggleBtn', s.pitchEnv.enabled ?? true, 'pitchEnvEnabled'); }
                if(s.lfo) { sl('lfoWaveform', s.lfo.waveform ?? 'sine'); ss('lfoRate', s.lfo.rate); ss('lfoAmount', s.lfo.amount); sl('lfoTarget', s.lfo.target ?? 'off'); st('lfoToggleBtn', s.lfo.enabled ?? true, 'lfoEnabled'); }
                if(s.portamento) { st('portaToggleBtn', s.portamento.enabled ?? false, 'portamentoEnabled'); ss('portaTime', s.portamento.time ?? 0.1); }
                if(s.effects?.delay) { sl('delayTimeSync', s.effects.delay.timeSync ?? '0.25'); ss('delayFeedback', s.effects.delay.feedback); ss('delayMix', s.effects.delay.mix); st('delayPingPongToggleBtn', s.effects.delay.pingPong ?? false, 'delayPingPong'); st('delayToggleBtn', s.effects.delay.enabled, 'delayEnabled'); }
                if(s.effects?.reverb && !document.getElementById('reverbToggleBtn').disabled) { ss('reverbPreDelay', s.effects.reverb.preDelay); ss('reverbTone', s.effects.reverb.tone); ss('reverbMix', s.effects.reverb.mix); st('reverbToggleBtn', s.effects.reverb.enabled, 'reverbEnabled'); }
                if(s.transport) { const e = document.getElementById('bpm'); if(e) { e.value = s.transport.bpm; e.dispatchEvent(new Event('change')); } }
                
                this.setSequencerLength(s.sequencerLength || 16);
                ss('sequencerLength', this.sequencerLength);
                
                if(s.steps) { this.steps = JSON.parse(JSON.stringify(s.steps)); this.redrawSequencerUI(); this.redrawVelocityUI(); }

                document.querySelectorAll('input, select').forEach(el => el.dispatchEvent(new Event('input', {bubbles: true})));
                console.log("State applied.");
            }

            setSequencerLength(len) {
                const newLength = Math.max(3, Math.min(32, len));
                if (newLength === this.sequencerLength) return;

                const oldLength = this.sequencerLength;
                this.sequencerLength = newLength;
                document.getElementById('sequencerLength').value = newLength;

                if (newLength > oldLength) {
                    for (let i = oldLength; i < newLength; i++) {
                        this.steps.push({ active: false, note: 'C3', velocity: 100 });
                    }
                } else {
                    this.steps.length = newLength;
                }
                this.initializeStepsUI();
                this.initializeVelocityUI();
            }
            
            async exportToWav() {
                console.log("Initializing WAV export...");
                const btn = document.getElementById('exportWavBtn');
                btn.textContent = 'Exporting...'; btn.disabled = true;
                try {
                    const params = this.gatherState();
                    const sr = this.audioContext.sampleRate;
                    const stepInterval = (60 / params.transport.bpm) / 4;
                    const totalDuration = (params.sequencerLength * stepInterval) + 5.0;
                    const offCtx = new OfflineAudioContext(2, Math.ceil(sr * totalDuration), sr);
                    const offFilter = offCtx.createBiquadFilter(); offFilter.type = 'lowpass'; offFilter.frequency.value = this.valueToLog(params.filter.cutoff, 20, 20000); offFilter.Q.value = params.filter.resonance;
                    const offMainGain = offCtx.createGain(); offMainGain.gain.value = params.master.volume; const offDelayNodeL = offCtx.createDelay(5.0); const offDelayNodeR = offCtx.createDelay(5.0); const offFeedbackL = offCtx.createGain(); const offFeedbackR = offCtx.createGain(); const offDelayWet = offCtx.createGain(); const offDelayDry = offCtx.createGain(); const offDelayIn = offCtx.createGain(); const offSplitter = offCtx.createChannelSplitter(2); const offMerger = offCtx.createChannelMerger(2);
                    const offRevPreDelay = offCtx.createDelay(0.5); const offRevConv = offCtx.createConvolver(); const offRevTone = offCtx.createBiquadFilter(); offRevTone.type = 'lowpass'; offRevTone.frequency.value = this.valueToLog(params.effects.reverb.tone, 1000, 20000); offRevTone.Q.value = 0.5; const offRevWet = offCtx.createGain();
                    if (this.impulseBuffer) { offRevConv.buffer = createSyntheticImpulse(offCtx); }
                    
                    offFilter.connect(offDelayIn); offDelayIn.connect(offDelayDry); offDelayIn.connect(offDelayWet); offDelayDry.connect(offRevPreDelay); offDelayWet.connect(offSplitter);
                    offSplitter.connect(offDelayNodeL, 0); offSplitter.connect(offDelayNodeR, 1);
                    offDelayNodeL.connect(offFeedbackL); offDelayNodeR.connect(offFeedbackR);
                    if (params.effects.delay.pingPong) { offFeedbackL.connect(offDelayNodeR); offFeedbackR.connect(offDelayNodeL); } else { offFeedbackL.connect(offDelayNodeL); offFeedbackR.connect(offDelayNodeR); }
                    offDelayNodeL.connect(offMerger, 0, 0); offDelayNodeR.connect(offMerger, 0, 1);
                    offMerger.connect(offRevPreDelay);
                    
                    offRevPreDelay.connect(offMainGain); offRevPreDelay.connect(offRevConv); offRevConv.connect(offRevTone); offRevTone.connect(offRevWet); offRevWet.connect(offMainGain); offMainGain.connect(offCtx.destination);
                    
                    const beatDuration = 60.0 / params.transport.bpm; const delayTime = beatDuration * parseFloat(params.effects.delay.timeSync);
                    offDelayNodeL.delayTime.value = delayTime; offDelayNodeR.delayTime.value = delayTime;
                    offFeedbackL.gain.value = params.effects.delay.feedback; offFeedbackR.gain.value = params.effects.delay.feedback;
                    offDelayWet.gain.value = params.effects.delay.enabled ? params.effects.delay.mix : 0; offDelayDry.gain.value = 1.0 - (params.effects.delay.enabled ? params.effects.delay.mix : 0);
                    offRevPreDelay.delayTime.value = params.effects.reverb.preDelay; offRevWet.gain.value = (params.effects.reverb.enabled && this.impulseBuffer) ? params.effects.reverb.mix : 0;
                    
                    let lastOfflineFreqs = { osc1: null, osc2: null };
                    for (let i = 0; i < params.sequencerLength; i++) {
                        const step = params.steps[i];
                        const time = i * stepInterval;
                        if (step.active && step.note && step.velocity > 0) {
                            const { fq1, fq2 } = this._createNoteVoice(offCtx, offFilter, time, step.note, step.velocity, lastOfflineFreqs, params);
                            lastOfflineFreqs = { osc1: fq1, osc2: fq2 };
                        }
                    }

                    console.log("Starting offline rendering...");
                    const renderedBuffer = await offCtx.startRendering();
                    console.log("Rendering complete.");
                    const wavData = this.bufferToWav(renderedBuffer, 16);
                    const blob = new Blob([wavData], { type: 'audio/wav' });
                    const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = 'kretzonizer_export.wav';
                    document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                    console.log("WAV export ready.");
                } catch (err) { console.error("Export Error:", err); alert(`Export failed: ${err.message}`); }
                finally { btn.textContent = 'Export to WAV'; btn.disabled = false; }
            }

            bufferToWav(abuffer, bitsPerSample) { const numChannels = abuffer.numberOfChannels, sampleRate = abuffer.sampleRate, format = 1, numFrames = abuffer.length; const blockAlign = numChannels * bitsPerSample / 8, byteRate = sampleRate * blockAlign, dataSize = numFrames * blockAlign; const buffer = new ArrayBuffer(44 + dataSize); const view = new DataView(buffer); this.writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); this.writeString(view, 8, 'WAVE'); this.writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, format, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitsPerSample, true); this.writeString(view, 36, 'data'); view.setUint32(40, dataSize, true); let offset = 44; const channels = []; for (let i = 0; i < numChannels; i++) channels.push(abuffer.getChannelData(i)); for (let i = 0; i < numFrames; i++) { for (let c = 0; c < numChannels; c++) { let sample = channels[c][i]; sample = Math.max(-1, Math.min(1, sample)); sample = sample < 0 ? sample * 32768 : sample * 32767; view.setInt16(offset, sample, true); offset += 2; } } return buffer; }
            writeString(view, offset, string) { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); }
        }

        function createOfflineNoiseBuffer(ctx) { if (!ctx?.sampleRate) return null; const size = Math.max(1, Math.ceil(ctx.sampleRate * 2)); const noiseBuffer = ctx.createBuffer(1, size, ctx.sampleRate); const output = noiseBuffer.getChannelData(0); for (let i = 0; i < size; i++) output[i] = Math.random() * 2 - 1; return noiseBuffer; }
        window.addEventListener('load', () => { try { window.kretzonizer = new StepSequencer(); console.log("Kretzonizer v3.8 Initialized"); } catch (e) { console.error("Initialization failed:", e); alert("Error initializing synthesizer. Check the console for details."); } });
    </script>
</body>
</html>
